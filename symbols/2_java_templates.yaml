# Bson object TypeTemplates
Templates:
    # Type templates
    CodeTypeTemplate: &CodeTypeTemplate null
    StringTypeTemplate: &StringTypeTemplate !!js/function >
        (str) => {
          let newStr = str;
          if (
            (str.charAt(0) === '\'' && str.charAt(str.length - 1) === '\'') ||
            (str.charAt(0) === '"' && str.charAt(str.length - 1) === '"')) {
            newStr = str.substr(1, str.length - 2);
          }
          return `"${newStr.replace(/\\([\s\S])|(")/g, '\\$1$2')}"`;
        }
    RegexTypeTemplate: &RegexTypeTemplate null
    BoolTypeTemplate: &BoolTypeTemplate null
    IntegerTypeTemplate: &IntegerTypeTemplate null
    DecimalTypeTemplate: &DecimalTypeTemplate null
    HexTypeTemplate: &HexTypeTemplate null
    OctalTypeTemplate: &OctalTypeTemplate !!js/function >
        (literal) => {
            if ((literal.charAt(0) === '0' && literal.charAt(1) === '0') ||
                (literal.charAt(0) === '0' && (literal.charAt(1) === 'o' || literal.charAt(1) === 'O'))) {
              return `0${literal.substr(2, literal.length - 1)}`;
            }
            return literal;
        }
    NumericTypeTemplate: &NumericTypeTemplate null
    ArrayTypeTemplate: &ArrayTypeTemplate !!js/function >
        (literal) => {
            return `Arrays.asList(${literal})`;
        }
    NullTypeTemplate: &NullTypeTemplate null
    UndefinedTypeTemplate: &UndefinedTypeTemplate !!js/function >
        () => {
            return 'null';
        }
    ObjectTypeTemplate: &ObjectTypeTemplate !!js/function >
        (literal) => {
            return `new Document()${literal}`;
        }
    ObjectTypeArgsTemplate: &ObjectTypeArgsTemplate !!js/function >
        (args) => {
            return args.reduce((str, pair) => {

                let newStr = pair[0];
                if (
                    (pair[0].charAt(0) === '\'' && pair[0].charAt(pair[0].length - 1) === '\'') ||
                    (pair[0].charAt(0) === '"' && pair[0].charAt(pair[0].length - 1) === '"')) {
                        newStr = pair[0].substr(1, pair[0].length - 2);
                }
                newStr = `"${newStr.replace(/\\([\s\S])|(")/g, '\\$1$2')}"`;

                return `${str}.append(${newStr}, ${pair[1]})`;
            }, '');
        }
    # Method templates
    CodeToJSONTemplate: &CodeToJSONTemplate null
    ObjectIdToJSONTemplate: &ObjectIdToJSONTemplate !!js/function >
        (lhs) => {
            return `${lhs}.toHexString`;
        }
    # Symbol templates
    CodeSymbolTemplate: &CodeSymbolTemplate null
    CodeSymbolArgsTemplate: &CodeSymbolArgsTemplate null
    ObjectIdSymbolTemplate: &ObjectIdSymbolTemplate null
    ObjectIdSymbolArgsTemplate: &ObjectIdSymbolArgsTemplate null
    # Utils templates
    ObjectIdCreateFromHexStringTemplate: &ObjectIdCreateFromHexStringTemplate !!js/function >
        () => {
            return '';
        }
    ObjectIdCreateFromHexStringArgsTemplate: &ObjectIdCreateFromHexStringArgsTemplate !!js/function >
        (lhs, arg) => {
            return `new ObjectId(${arg})`;
        }
    ObjectIdCreateFromTimeTemplate: &ObjectIdCreateFromTimeTemplate !!js/function >
        () => {
            return '';
        }
    ObjectIdCreateFromTimeArgsTemplate: &ObjectIdCreateFromTimeArgsTemplate !!js/function >
        (lhs, arg) => {
            return `new ObjectId(new java.util.Date(${arg}))`;
        }
    ObjectIdIsValidTemplate: &ObjectIdIsValidTemplate null
    ObjectIdIsValidArgsTemplate: &ObjectIdIsValidArgsTemplate null
