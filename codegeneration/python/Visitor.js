/* eslint complexity: 0 camelcase: 0*/
const {
  BsonTranspilersArgumentError,
  BsonTranspilersRuntimeError,
  BsonTranspilersInternalError,
  BsonTranspilersUnimplementedError
} = require('../../helper/error');
const { removeQuotes } = require('../../helper/format');

/**
 * This is a Visitor that visits the tree generated by the Python3.g4 grammar.
 *
 * @param {CodeGenerationVisitor} CodeGenerationVisitor - class shared between
 * all visitors.
 * @return {Visitor} - Input-language specific visitor.
 */
module.exports = (CodeGenerationVisitor) => class Visitor extends CodeGenerationVisitor {
  constructor() {
    super();
    this.startRule = 'file_input'; // Name of the ANTLR rule to start

    this.processfloat = this.processint;
    this.processInt64 = this.processint;


    // Throw UnimplementedError for nodes with expressions that we don't support
    this.visitDel_stmt =
    this.visitPass_stmt =
    this.visitFlow_stmt =
    this.visitImport_stmt =
    this.visitGlobal_stmt =
    this.visitNonlocal_stmt =
    this.visitAssert_stmt =
    this.visitIf_stmt =
    this.visitWhile_stmt =
    this.visitFor_stmt =
    this.visitTry_stmt =
    this.visitWith_stmt =
    this.visitFuncdef =
    this.visitClassdef =
    this.visitDecorated =
    this.visitAsync_stmt =
    this.visitComp_iter =
    this.visitStar_expr =
    this.visitInline_if =
    this.visitAssign_stmt =
    this.visitEllipsesAtom =
    this.visitAugassign =
      this.unimplemented;
  }

  /**
   * Takes in the constructor name of a node and returns a human-readable
   * node name. Used for error reporting.
   * @param {String} name
   * @return {String}
   */
  renameNode(name) {
    return name ? name.replace('_stmt', '') : 'Expression';
  }

  visitFunctionCall(ctx) {
    // Skip if fake node
    if (ctx.getChildCount() === 1) {
      return this.visitChildren(ctx);
    }
    return this.generateFunctionCall(ctx);
  }

  visitIdentifier(ctx) {
    return this.generateIdentifier(ctx);
  }


  visitAttributeAccess(ctx) {
    // Skip if fake node
    if (ctx.getChildCount() === 1) {
      return this.visitChildren(ctx);
    }
    return this.generateAttributeAccess(ctx);
  }

  visitObject_literal(ctx) {
    if (ctx.dictorsetmaker()) {
      this.testComprehension(ctx.dictorsetmaker());
    }
    return this.generateObjectLiteral(ctx);
  }

  visitSet_literal(ctx) {
    ctx.type = this.Types._array;
    ctx.indentDepth = this.getIndentDepth(ctx) + 1;
    this.requiredImports[9] = true;
    let args = '';
    const list = ctx.testlist_comp();
    this.testComprehension(list);
    if (list) {
      // Sets of 1 item is the same as the item itself, but keep parens for math
      if (list.children.length === 1) {
        return `(${this.visit(list.children[0])})`;
      }
      const visitedChildren = list.children.map((child) => {
        return this.visit(child);
      });
      const visitedElements = visitedChildren.filter((arg) => {
        return arg !== ',';
      });
      if (ctx.type.argsTemplate) { // NOTE: not currently being used anywhere.
        args = visitedElements.map((arg, index) => {
          const last = !visitedElements[index + 1];
          return ctx.type.argsTemplate(arg, ctx.indentDepth, last);
        }).join('');
      } else {
        args = visitedElements.join(', ');
      }
    }
    if (ctx.type.template) {
      return ctx.type.template(args, ctx.indentDepth);
    }
    return this.visitChildren(ctx);
  }

  visitArray_literal(ctx) {
    ctx.type = this.Types._array;
    ctx.indentDepth = this.getIndentDepth(ctx) + 1;
    this.requiredImports[9] = true;
    let args = '';
    if (ctx.testlist_comp()) {
      this.testComprehension(ctx.testlist_comp());
      const visitedChildren = ctx.testlist_comp().children.map((child) => {
        return this.visit(child);
      });
      const visitedElements = visitedChildren.filter((arg) => {
        return arg !== ',';
      });
      if (ctx.type.argsTemplate) { // NOTE: not currently being used anywhere.
        args = visitedElements.map((arg, index) => {
          const last = !visitedElements[index + 1];
          return ctx.type.argsTemplate(arg, ctx.indentDepth, last);
        }).join('');
      } else {
        args = visitedElements.join(', ');
      }
    }
    if (ctx.type.template) {
      return ctx.type.template(args, ctx.indentDepth);
    }
    return this.visitChildren(ctx);
  }

  /**
   * Need process method because we want to pass the argument type to the template
   * so that we can determine if the generated number needs to be parsed or casted.
   *
   * @param {Object} ctx
   * @returns {String}
   */

  processint(ctx) {
    const lhsStr = this.visit(ctx.atom());
    let lhsType = this.findTypedNode(ctx.atom()).type;
    if (typeof lhsType === 'string') {
      lhsType = this.Types[lhsType];
    }

    // Get the original type of the argument
    const expectedArgs = lhsType.args;
    let args = this.checkArguments(
      expectedArgs, this.getArguments(ctx), lhsType.id
    );
    let argType;

    if (args.length === 0) {
      args = ['0'];
      argType = this.Types._integer;
    } else {
      const argNode = this.getArgumentAt(ctx, 0);
      const typed = this.findTypedNode(argNode);
      argType = typed.originalType !== undefined ?
        typed.originalType :
        typed.type;
    }

    return this.generateCall(
      ctx, lhsType, [args[0], argType.id], lhsStr, `(${args.join(', ')})`
    );
  }


  /**
   * Convert between numeric types. Required so that we don't end up with
   * strange conversions like 'Int32(Double(2))', and can just generate '2'.
   *
   * @param {Array} expectedType - types to cast to.
   * @param {antlr4.ParserRuleContext} ctx - ctx to cast from, if valid.
   *
   * @returns {String} - visited result, or null on error.
   */
  castType(expectedType, ctx) {
    const result = this.visit(ctx);
    const typedCtx = this.findTypedNode(ctx);
    const type = typedCtx.type;

    // If the types are exactly the same, just return.
    if (expectedType.indexOf(type) !== -1 ||
      expectedType.indexOf(type.id) !== -1) {
      return result;
    }

    const numericTypes = [
      this.Types._integer, this.Types._decimal, this.Types._hex,
      this.Types._octal, this.Types._long
    ];
    // If both expected and node are numeric literals, cast + return
    for (let i = 0; i < expectedType.length; i++) {
      if (numericTypes.indexOf(type) !== -1 &&
        numericTypes.indexOf(expectedType[i]) !== -1) {
        // Need to visit the octal node always
        if (type.id === '_octal') {
          return this.leafHelper(
            expectedType[i],
            {
              type: expectedType[i],
              originalType: type.id,
              getText: () => ( this.visit(ctx) )
            }
          );
        }
        const child = this.skipFakeNodesDown(ctx);
        child.originalType = type;
        child.type = expectedType[i];
        return this.leafHelper(expectedType[i], child);
      }
    }

    // If the expected type is "numeric", accept the number basic & bson types
    if (expectedType.indexOf(this.Types._numeric) !== -1 &&
      (numericTypes.indexOf(type) !== -1 || (type.code === 106 || type.code === 105 || type.code === 104))) {
      return result;
    }
    // If the expected type is any number, accept float/int
    if ((numericTypes.some((t) => ( expectedType.indexOf(t) !== -1))) &&
      (type.code === 106 || type.code === 105 || type.code === 104)) {
      return result;
    }

    return null;
  }


  getParentOriginalType(ctx) {
    if (ctx.originalType !== undefined) {
      return ctx.originalType;
    }
    if (ctx.parentCtx) {
      return this.getParentOriginalType(ctx.parentCtx);
    }
    return null;
  }

  /**
   * Helper for literals.
   *
   * @param {Object} setType
   * @param {ParserContext} ctx
   * @return {String}
   */
  leafHelper(setType, ctx) {
    ctx.type = setType;
    this.requiredImports[ctx.type.code] = true;
    // Pass the original argument type to the template, not the casted type.

    const parentOriginalType = this.getParentOriginalType(ctx);
    const type = parentOriginalType === null ? ctx.type : parentOriginalType;

    if (`process${ctx.type.id}` in this) {
      return this[`process${ctx.type.id}`](ctx);
    }
    const children = ctx.getText();
    return this.generateLiteral(ctx, ctx.type, [children, type.id], children, true);
  }

  visitStringAtom(ctx) {
    ctx.type = this.Types._string;
    this.requiredImports[ctx.type.code] = true;
    // Pass the original argument type to the template, not the casted type.
    const type = ctx.originalType === undefined ? ctx.type : ctx.originalType;

    let result = this.visitChildren(ctx);
    result = result.replace(/^([rubf]?[rubf]["']|'''|"""|'|")/gi, '');
    result = result.replace(/(["]{3}|["]|[']{3}|['])$/, '');
    return this.generateLiteral(ctx, ctx.type, [result, type.id], `'${result}'`, true);
  }
  visitInteger_literal(ctx) {
    return this.leafHelper(this.Types._long, ctx);
  }
  visitOct_literal(ctx) {
    return this.leafHelper(this.Types._octal, ctx);
  }
  visitHex_literal(ctx) {
    return this.leafHelper(this.Types._hex, ctx);
  }
  visitBin_literal(ctx) {
    return this.leafHelper(this.Types._bin, ctx);
  }
  visitFloat_literal(ctx) {
    return this.leafHelper(this.Types._decimal, ctx);
  }
  visitImag_literal(ctx) {
    return this.leafHelper(this.Types._long, ctx); // TODO: imaginary numbers?
  }
  visitBoolean_literal(ctx) {
    return this.leafHelper(this.Types._bool, ctx);
  }
  visitNone_literal(ctx) {
    return this.leafHelper(this.Types._null, ctx);
  }

  visitExpr_stmt(ctx) {
    if (
      ('assign_stmt' in ctx && ctx.assign_stmt() !== null) ||
      ('augassign' in ctx && ctx.augassign() !== null) ||
      ('annassign' in ctx && ctx.annassign() !== null)
    ) {
      throw new BsonTranspilersUnimplementedError(
        'Assignment not yet implemented'
      );
    }
    return this.visitChildren(ctx);
  }

  /**
   * For the expression "+1", set the type to the child's type.
   * @param {ParserContext} ctx
   * @return {String}
   */
  visitFactor(ctx) {
    // Skip if fake node
    if (ctx.getChildCount() === 1) {
      return this.visitChildren(ctx);
    }
    const result = this.visitChildren(ctx);
    ctx.type = this.findTypedNode(ctx.factor()).type;
    return result;
  }

  visitTerm(ctx) {
    // Skip if fake node
    if (ctx.getChildCount() === 1) {
      return this.visitChildren(ctx);
    }
    if (ctx.getChildCount() > 2) {
      const res = [this.visit(ctx.children[0])];
      for (let i = 1; i < ctx.getChildCount(); i++) {
        const op = this.visit(ctx.children[i]);
        if (op === '//') {
          const rhs = this.visit(ctx.children[i + 1]);
          const lhs = res.pop();
          res.push(this.Syntax.floorDiv.template(lhs, rhs));
          i++;
        } else {
          res.push(op);
        }
      }
      return res.join('');
    }
    return this.visitChildren(ctx);
  }

  visitPower(ctx) {
    // Skip if fake node
    if (ctx.getChildCount() === 1) {
      return this.visitChildren(ctx);
    }
    return this.Syntax.power.template(this.visit(ctx.atom()), this.visit(ctx.factor()));
  }

  visitAnd_test(ctx) {
    // Skip if fake node
    if (ctx.getChildCount() === 1) {
      return this.visitChildren(ctx);
    }
    return this.Syntax.and.template(ctx.not_test().map((t) => ( this.visit(t) )));
  }

  visitOr_test(ctx) {
    // Skip if fake node
    if (ctx.getChildCount() === 1) {
      return this.visitChildren(ctx);
    }
    return this.Syntax.or.template(ctx.and_test().map((t) => ( this.visit(t) )));
  }

  visitNot_test(ctx) {
    // Skip if fake node
    if (ctx.getChildCount() === 1) {
      return this.visitChildren(ctx);
    }
    return this.Syntax.not.template(this.visit(ctx.children[1]));
  }

  visitComparison(ctx) {
    // Skip if fake node
    if (ctx.getChildCount() === 1) {
      return this.visitChildren(ctx);
    }
    let skip = false;
    return ctx.children.reduce((str, e, i, arr) => {
      if (skip) { // Skip for 'in' statements because swallows rhs
        skip = false;
        return str;
      }
      if (i === arr.length - 1) { // Always visit the last element
        return `${str}${this.visit(e)}`;
      }
      if (i % 2 === 0) { // Only ops
        return str;
      }
      const op = this.visit(e);
      if (op === '==' || op === '!=' || op === 'is' || op === 'isnot') {
        return `${str}${this.Syntax.equality.template(this.visit(arr[i - 1]), op, '')}`;
      }
      if (op === 'in' || op === 'notin') {
        skip = true;
        return `${str}${this.Syntax.in.template(this.visit(arr[i - 1]), op, this.visit(arr[i + 1]))}`;
      }
      return `${str}${this.visit(arr[i - 1])} ${op} `;
    }, '');
  }


  visitIndexAccess(ctx) {
    // Skip if fake node
    if (ctx.getChildCount() === 1) {
      return this.visitChildren(ctx);
    }
    throw new BsonTranspilersUnimplementedError('Indexing not currently supported');
  }

  // TODO: translate flags
  // process_regex(ctx) { // eslint-disable-line camelcase
  //   ctx.type = this.Types._regex;
  //   let pattern;
  //   let flags;
  // }
  // processcompile(ctx) {
  //   return this.process_regex(ctx);
  // }
  /**
   * Process BSON regexps because we need to verify the flags are valid.
   *
   * @param {FuncCallExpressionContext} ctx
   * @return {string}
   */
  processRegex(ctx) {
    ctx.type = this.Types.Regex;
    const symbolType = this.Symbols.Regex;

    const args = this.checkArguments(
      symbolType.args, this.getArguments(ctx), 'Regex'
    );

    let flags = null;
    const pattern = args[0];
    if (args.length === 2) {
      flags = args[1];
      for (let i = 1; i < flags.length - 1; i++) {
        if (!(flags[i] in this.Syntax.bsonRegexFlags)) {
          throw new BsonTranspilersRuntimeError(
            `Invalid flag '${flags[i]}' passed to Regexp`
          );
        }
      }
      flags = flags.replace(/[imxlsu]/g, m => this.Syntax.bsonRegexFlags[m]);
    }

    return this.generateCall(
      ctx, symbolType, [pattern, flags], 'Regex',
      `(${pattern}${flags ? ', ' + flags : ''})`
    );
  }
  /**
   * Code is processed in every language because want to generate the scope as
   * a non-idiomatic document.
   *
   * @param {ParserContext} ctx
   * @return {String}
   */
  processCode(ctx) {
    ctx.type = this.Types.Code;
    const symbolType = this.Symbols.Code;
    const args = this.checkArguments(symbolType.args, this.getArguments(ctx), 'Code');
    let scopeStr = '';

    if (args.length === 2) {
      const idiomatic = this.idiomatic;
      this.idiomatic = false;
      const scope = this.visit(this.getArgumentAt(ctx, 1));
      this.idiomatic = idiomatic;
      scopeStr = `, ${scope}`;
      this.requiredImports[113] = true;
      this.requiredImports[10] = true;
      args[1] = scope;
    }
    return this.generateCall(ctx, symbolType, args, 'Code', `(${args[0]}${scopeStr})`);
  }

  processdatetime(ctx) {
    ctx.type = this.Types.Date;
    ctx.wasNew = true; // Always true for non-js
    const symbolType = this.Symbols.datetime;
    let date = null;

    const argsList = this.getArguments(ctx);
    if (argsList.length !== 0) {
      if (argsList.length < 3) {
        throw new BsonTranspilersArgumentError(
          `Wrong number of arguments to datetime: needs at at least 3, got ${argsList.length}`
        );
      }

      try {
        this.checkArguments(symbolType.args, argsList, 'datetime');
      } catch (e) {
        throw new BsonTranspilersArgumentError(
          `Invalid argument to datetime: requires either no args or up to 7 numbers. ${e.message}`
        );
      }

      const argvals = argsList.map((k) => {
        let v;
        try {
          v = parseInt(k.getText(), 10);
        } catch (e) {
          throw new BsonTranspilersRuntimeError(
            `Unable to convert datetime argument to integer: ${k.getText()}`
          );
        }
        if (isNaN(v)) {
          throw new BsonTranspilersRuntimeError(
            `Unable to convert datetime argument to integer: ${k.getText()}`
          );
        }
        return v;
      });
      argvals[1]--; // month is 0-based in node, 1-based in everything else (afaict)
      try {
        date = new Date(Date.UTC(...argvals));
      } catch (e) {
        throw new BsonTranspilersInternalError(
          `Unable to construct date from arguments: ${e.message}`
        );
      }
    }
    const dargs = `Date(${date
      ? this.Types._string.template(date.toUTCString())
      : ''})`;
    return this.generateCall(
      ctx, symbolType, [date, false], '', dargs, false, true
    );
  }

  /**
   * Gets a process method because need to tell the template if
   * the argument is a number or a date.
   *
   * @param {ParserRuleContext} ctx
   * @returns {String} - generated code
   */
  processObjectIdfrom_datetime(ctx) {
    const lhsStr = this.visit(ctx.atom());
    let lhsType = this.findTypedNode(ctx.atom()).type;
    if (typeof lhsType === 'string') {
      lhsType = this.Types[lhsType];
    }

    const args = this.checkArguments(
      lhsType.args, this.getArguments(ctx), lhsType.id
    );
    const isNumber = this.findTypedNode(this.getArgumentAt(ctx, 0)).type.code !== 200;
    return this.generateCall(
      ctx, lhsType, [args[0], isNumber], lhsStr, `(${args.join(', ')})`, true
    );
  }

  /**
   * Binary needs preprocessing because it needs to be executed. Manually check
   * argument length because 'Buffer' not supported.
   *
   * TODO: figure out if it ever makes sense to support Binary.
   */
  processBinary() {
    throw new BsonTranspilersUnimplementedError('Binary type not supported');
  }


  /**
   * Returns true if the type of the child is a literal.
   *
   * @param {ParserRuleContext} ctx
   * @return {boolean}
   */
  isLiteralCtx(ctx) {
    return [
      'integer_literal', 'oct_literal', 'hex_literal', 'bin_literal',
      'float_literal', 'string_literal', 'none_literal', 'boolean_literal'
    ].filter((n) => ( n in ctx.parentCtx )).length > 0;
  }

  /**
   * Want to throw unimplemented for comprehensions instead of reference errors.
   * @param {ParserContext} ctx
   */
  testComprehension(ctx) {
    if (ctx === null) {
      return;
    }
    if (('comp_for' in ctx && ctx.comp_for() !== null) || ('comp_if' in ctx && ctx.comp_if() !== null)) {
      throw new BsonTranspilersUnimplementedError(
        'Comprehensions not yet implemented'
      );
    }
  }

  // accessors
  getList(ctx) {
    if (!('testlist_comp' in ctx) || !ctx.testlist_comp()) {
      return [];
    }
    return ctx.testlist_comp().test();
  }
  getArray(ctx) {
    return this.skipFakeNodesDown(ctx, 'array_literal');
  }
  getObject(ctx) {
    return this.skipFakeNodesDown(ctx, 'object_literal');
  }
  getKeyValueList(ctx) {
    if ('dictorsetmaker' in ctx && ctx.dictorsetmaker()) {
      const properties = ctx.dictorsetmaker().test();
      return properties
        .map((key, i) => {
          if (i % 2 === 0) {
            return [
              key,
              properties[i + 1]
            ];
          }
          return null;
        })
        .filter((k) => (k !== null));
    }
    return [];
  }
  getKeyStr(k) {
    return removeQuotes(this.visit(k[0]));
  }
  getParentKeyStr(ctx) { // TODO: fix for long list
    const topNode = this.getParentUntil(ctx.parentCtx, 'dictorsetmaker', 1);
    const objNode = topNode.parentCtx;
    const index = objNode.test().indexOf(topNode);
    const keyNode = objNode.test()[index - 1];
    const key = this.visit(keyNode);
    return removeQuotes(key);
  }
  getValue(k) {
    return k[1];
  }
  getArguments(ctx) {
    const trailer = ctx.paren_trailer();
    if (!('arglist' in trailer) || trailer.arglist() === null) {
      return [];
    }
    return trailer.arglist().argument();
  }
  getArgumentAt(ctx, i) {
    return this.getArguments(ctx)[i];
  }
  getParentUntil(ctx, name, steps) {
    steps = steps === undefined ? 0 : steps;
    let res = ctx;
    let found = false;
    const stack = [];
    while (res !== undefined && res !== null && !found) {
      if (name in res) {
        const goal = res[name]();
        if (goal === stack[stack.length - 1]) {
          found = true;
          break;
        }
      }
      stack.push(res);
      res = res.parentCtx;
    }
    return found ? stack[stack.length - 1 - steps] : false;
  }
  skipFakeNodesDown(ctx, goal) {
    let res = ctx;
    while (res.children !== undefined && res.children.length === 1) {
      res = res.children[0];
      if (goal && goal in res) {
        res = res[goal]();
        break;
      }
    }
    if (res.children === undefined) {
      return res.parentCtx;
    }
    return res;
  }
  skipFakeNodesUp(ctx, goal) {
    let res = ctx.parentCtx;
    while (res !== undefined && res !== null && res.children !== undefined && res.children.length === 1) {
      if (goal && goal in res) {
        res = res[goal]();
        break;
      }
      res = res.parentCtx;
    }
    return res;
  }
  isSubObject(ctx) {
    return this.getParentUntil(ctx.parentCtx, 'dictorsetmaker', 1);
  }
  getObjectChild(ctx) {
    return this.skipFakeNodesDown(ctx);
  }
  getFunctionCallName(ctx) {
    return ctx.atom();
  }
  getIfIdentifier(ctx) {
    if ('identifier' in ctx) {
      return ctx.identifier();
    }
    return ctx;
  }
  getAttributeLHS(ctx) {
    return ctx.atom();
  }
  getAttributeRHS(ctx) {
    return ctx.dot_trailer().identifier();
  }
};

