# Contributing to bson-compilers

## Setting up your environment
`bson-compilers` uses
[antlr](https://github.com/antlr/antlr4/blob/master/doc/javascript-target.md)
to help create an AST. As `antlr` is written in Java, you will need to set up a
few tools before being able to compile this locally. 

Make sure you have Java installed:
```shell
$ brew cask install java
```

Download `antlr`:
```shell
$ cd /usr/local/lib && curl -O http://www.antlr.org/download/antlr-4.7.1-complete.jar
```

You will then need to add it to your `$CLASSPATH`:
```shell
$ export CLASSPATH=".:/usr/local/lib/antlr-4.7.1-complete.jar:$CLASSPATH"
```

Alias `antlr4` and `grun`:
```shell
$ alias antlr4='java -Xmx500M -cp "/usr/local/lib/antlr-4.7.1-complete.jar:$CLASSPATH" org.antlr.v4.Tool' && alias grun='java org.antlr.v4.gui.TestRig'
```

Then compile and run tests locally with:
```shell
$ npm run compile && npm run test
```

You can provide a few environmental variables to help you test your specific
output and input languages. If none are provided, everything will run.
- __INPUT=:__ input language you want to test
- __OUTPUT=:__ output language you want to test
- __MODE=:__ works with either success or error test modes

```shell
OUTPUT=csharp INPUT=shell MODE=success npm run test 
```

## Compilation Stages
### #1. Parsing
Parsing and tree generation is handled by ANTLR4 (so some familiarity with ANTLR
is good). The grammar files are located in the `grammars` folder, and the 
parser/lexer/etc generated from the grammar are located in `lib/antlr`. To make
changes to the grammar, you have to modify the `.g4` file in `grammars`, then 
run `npm run compile`. You should never directly modify files in `lib`.

Each grammar will generate a tree that is unique to the grammar. This means that
for the same input code, the tree generated from ECMAScript.g4 is not going to be
exactly the same as the tree generated by Python3.g4. As a result, we need different
visitors for each tree.

ANTLR generates a empty "Visitor" class for the tree that is generated by the parser.
The "Visitor" class will be located in `lib/antlr/<input language>Visitor.js`.

### #2. Visitor
Because the project is designed to handle multiple input languages and multiple 
output languages, the tree visitation stage is split into two parts. The first part
is handled in the Visitor class defined in `codegeneration/<input language>/Visitor.js`.
It visits the tree generated in step #1, and is a subclass of the empty visitor 
class generated in `lib/antlr`. This Visitor class <b>is specific to the input 
language</b> and can only visit a tree generated by one grammar. The visitor will
visit each node and use a template defined in the symbol table to generate code 
in the target language. For expressions that are too complex for a string template,
the visitor will call an `emit` method defined in step #3.

The visitor will also tag each node with a type, which are defined in the `Types`
table. This is useful for checking arguments types, attributes, methods, etc.

When the visitor reaches a literal or an identifier (so either a variable or a function call),
it will look up in the Symbol Table [TODO: Add link to symbol table section] to see
if the variable is defined and in scope. Where possible, the symbol table also includes a string template
for each symbol. This is a function that takes in the name of the symbol and generates 
the name in the target language. So for example, `Long` in javascript gets generated to
`NumberLong` in shell. Functions also have `argsTemplates`, which is a string template that
takes in the `lhs`, i.e. the left-hand-side of the statement, and the arguments. It returns
a string with the arguments transformed to the target language. [TODO: expand]

### #3. Generator
The second half of the tree visitation stage. Each target (output) language will 
have a Generator class defined in `codegeneration/<target language>/Generator.js`. 
The Generator class generates code, so it is <b> specific to the target language.
</b> The Generator class is a subclass of the input language's Visitor class. 
So for example, translating between JS and Python, the order of inheritance will be:
   1. `lib/antlr/ECMAScriptVisitor.js` [superclass]
   2. `codegeneration/javascript/Visitor.js`
   3. `codegeneration/python/Generator.js`

For nodes that cannot be translated using 
templates, the Generator class will define a method called `emit<expr name>` which
takes in a tree node, some optional metadata, and returns the transformed string.

To figure out the `emit` method name, you'd have to look up the symbol type's
id in either `Symbols` or `Types` of the input's Symbol Table directory. For
example, if you're modifying `Date` Type, you can find that this type's `id` is
`Date` and therefore can modify it in the Generator with `emitDate` function:

```yml
Date: # Needs emit method
    # id to modify the type with:
    id: "Date"
    callable: *constructor
    args: null
    type: *DateType
```

Modifying output in the Generator should only be done if it's not possible to
modify it in the output language's `Symbol Template`. That is, if the output
doesn't follow a standard pattern, or if the input has to be first processed in
the `Visitor`, which will then pass on the processed parameter to the
Generator.


## Project Structure
Entry point to the project is `index.js`. It currently exports [two
APIs](https://github.com/mongodb-js/bson-compilers#api), compiling a string
given `inputLang` and `outputLang`, and accessing language's import statements
you might need.

To construct a compiler, `index.js` needs 3 components:
- `codegeneration/<input language>/Visitor.js` The visitor for the input language.
- `codegeneration/<target language>/Generator.js` - The generator for the output language.
- `lib/symbol-table/<input language>to<target language>.js` - The symbol table for 
the input+output combination.

<img alt="indexjs" width="60%" align="right" src="/img-docs/indexjs.jpg"/>

<p align="left">
  <br><br>
  The <code>getCompiler()</code> function takes in three arguments:
  <code>visitor</code>, <code>generator</code> and <code>symbols</code> to create
  a compiler
  and a <code>parse tree</code> that can be walked.
  <br><br><br>
</div>


### Symbol Tables [TODO: expand]
<img alt="symboltablescope" width="50%" align="right" src="/img-docs/symbolscope.jpg"/>

As the Visitor visits each expression in a code block, it pushes the current
scope onto the Symbol Table. As we leave the code block, that scope is popped
off the Symbol Table. See illustration on the right.

There are three types of symbol tables in this project: `Symbols`, `Types` and
`Templates`. Input languages are responsible for the first two. `Templates` are
used for generating output based on `Symbols` and `Types`. For example, if an
input in Javacript consists of `ObjectId().toString`, we are looking at the
following table in `Types` in `javascript` directory:

<br><br>

```yml
# in output language 'Templates', we can find this piece of code under
# 'ObjectIdSymbolTemplate' 
ObjectId: &ObjectIdType
    <<: *__type
    # if we need to handle this symbol type in either Visitor or Generator, it
    # can be accessed via 'ObjectId'
    id: "ObjectId"
    type: *ObjectType
    attr:
        toString:
            # if toString needs to be handled differently this code block can
            # also have an 'id' field  that can be accessed in either Visitor
            # or Generator files
            <<: *__func
            type: *StringType
            # to access 'toString' in output language 'Templates', use the two
            # properties below
            template: *ObjectIdToStringTemplate
            argsTemplate: *ObjectIdToStringArgsTemplate
```

#### TL;DR
- __Visitor:__ selectively visits nodes; processes input language via
  `processs` methods and sends information to either output language's `Symbol
Template` or `Generator`.
- __Generator:__ processes output language via `emit` methods.
- __Symbol Template:__ does string manipulation to provide output based on
  Symbol Type.
- __Symbol Type / Symbols:__ provides indication on the type of input.

### Tests
Tests for output based on input are broken into two modes: `error` and
`success`. They are stored in `.json` files to easier test multiple outputs per
input language. Each input language has its own directory to be able to handle
input language's edge cases better.

## Adding an Output Language

1. Create a directory in `symbols` directory for your output language:
```shell
mkdir symbols/{OUTPUT_LANG}
```
2. Create a `templates.yaml` file to store your language's templates. Inside
   you'll probably want to copy the contents from an existing `templates` file,
clear all `!!js/function >` and replace them with `null`
```shell
touch symbols/{OUTPUT_LANG}/templates.yaml
```
3. You should now run `npm run compile` to generate a complete symbol table.
   This will be generated in `lib/symbol-table/javascriptto{OUTPUT_LANG}` and
`lib/symbol-table/shellto{OUTPUT_LANG}`.
4. You will have to require the generated symbol tables in `index.js`:
```js
const javascript{OUTPUT_LANG}symbols = require('lib/symbol-table/javascriptto{OUTPUT_LANG}')
const shell{OUTPUT_LANG}symbols = require('lib/symbol-table/shellto{OUTPUT_LANG}')
// and then add another export to module.exports at the bottom of the file:

module.exports = {
  javascript: {
    // all those js exports,
    {OUTPUT_LANG}: getCompiler(JavascriptVisitor, {OUTPUT_LANG}Generator, javascrip{OUTPUT_LANG}symbols)
  }
  shell: {
    // all those js exports,
    {OUTPUT_LANG}: getCompiler(ShellVisitor, {OUTPUT_LANG}Generator, shell{OUTPUT_LANG}symbols)
  }
}
```
5. We still don't have a `Generator.js` file required above, so that won't
   quite work yet. So next, create a new directory in `codegeneration` for your
output language:
```shell
mkidr codegenration/{OUTPUT_LANG}
```
6. And create a generator file:
```shell
touch codegeneration/{OUTPUT_LANG}/Generator.js
```
7. You will need some boiler plate to get you going as the input language's
   Visitor file will be looking for a few things. We'd recommend you start with
something like this:
```js
// a lot of languages prefer double quote strings, so there is a helper method
// for that. All other formatters can be found or adjusted in the same file.

const { doubleQuoteStringify } = require('../../helper/format');

// superclass is the input language's visitor file
module.exports = (superclass) => class ExtendedVisitor extends superclass {
  constructor() {
    super();
    // whether or not your output language needs the word new. If that's not
    // the case, remove this line
    this.new = 'new ';
    // regex flags might vary, so we create this object in the Generator file
    this.regexFlags = {
      i: 'i',  // ignore case
      m: 'm',  // multiline
      u: '', // unicode
      y: '',   // sticky search
      g: ''    // global
    };
    // same goes for bsonRegexFlags
    this.bsonRegexFlags = {
      'i': 'i', // Case insensitivity to match
      'm': 'm', // Multiline match
      'x': 'x', // Ignore all white space characters
      's': 's', // Matches all
      'l': '', // Case-insensitive matching dependent on the current locale?
      'u': '' // Unicode?
    };
  }
  // if any emit methods are necessary, they will go here, for example:
  emitDate(ctx, date) {
    // handle date conversion to output lang
  }
  // certain types need to be processed in the visitor file first. To check if
  // your emit function should take parameters, check the input language's
  // Visitor file.
};
```
8. You can now require the generator file in `index.js`:
```
const {OUTPUT_LANG}Generator = require('./codegeneration/{OUTPUT_LANG}/Generator')
```
9. Next thing is tests! Tests are organized under two modes: `error` and
   `success`. Each input language has it's own directory. You can edit output test
cases in each file in those directories based on what the output should be. For example:
```json
// this test is in /test/json/success/javascript/bson-constructors.json
// it's testing different ouptut based on on javascript intput of "{x: {y: '2'}}"
  {
    "description": "Doc with subdoc",
    "javascript": "{x: {y: '2'}}",
    "python": "{'x': {'y': '2'}}",
    "java": "new Document(\"x\", new Document(\"y\", \"2\"))",
    "csharp": "new BsonDocument(\"x\", new BsonDocument(\"y\", \"2\"))",
    "shell": "{x: {y: '2'}}",
    "OUTPUT_LANG": "OUTPUT_CODE"
  },
```

## Adding an Input Language
TODO!
