/* eslint complexity: 0 */
const Python3Visitor = require('../../lib/antlr/Python3Visitor').Python3Visitor;
const { removeQuotes } = require('../../helper/format');

/**
 * This is a Visitor that visits the tree generated by the Python3.g4 grammar.
 *
 * @returns {Visitor}
 */
class Visitor extends Python3Visitor {
  constructor() {
    super();
    this.requiredImports = {};
    this.idiomatic = true;
  }
  deepCopyRequiredImports() {
    const copy = Object.assign({}, this.requiredImports);
    [300, 301, 302, 303, 304, 305, 306].forEach((i) => {
      copy[i] = Array.from(this.requiredImports[i]);
    });
    return copy;
  }
  /**
   * Selectively visits children of a node.
   *
   * @param {ParserRuleContext} ctx
   * @param {Object} options:
   *    start - child index to start iterating at.
   *    end - child index to end iterating after.
   *    step - how many children to increment each step, 1 visits all children.
   *    separator - a string separator to go between children.
   *    ignore - an array of child indexes to skip.
   *    children - the set of children to visit.
   * @returns {String}
   */
  visitChildren(ctx, options) {
    // console.log(`visitChildren: ${ctx.constructor.name} children.length=${ctx.children.length}`);
    const opts = {
      start: 0, step: 1, separator: '', ignore: [], children: ctx.children
    };
    Object.assign(opts, options ? options : {});
    opts.end = ('end' in opts) ? opts.end : opts.children.length;

    let code = '';
    for (let i = opts.start; i < opts.end; i += opts.step) {
      if (opts.ignore.indexOf(i) === -1) {
        code = `${ code }${ this.visit(opts.children[i]) }${
          (i === opts.end - 1) ?
            '' :
            opts.separator
        }`;
      }
    }
    /* Set the node's type to the first child, if it's not already set.
      More often than not, type will be set directly by the visitNode method. */
    if (ctx.type === undefined) {
      ctx.type = opts.children.length ?
        opts.children[0].type :
        this.Types._undefined;
    }
    return code.trim();
  }

  start(ctx) {
    this.requiredImports = {};
    [300, 301, 302, 303, 304, 305, 306].forEach(
      (i) => (this.requiredImports[i] = [])
    );
    return this.visitExpr_stmt(ctx);
  }

  getIndentDepth(ctx) {
    while (ctx.indentDepth === undefined) {
      ctx = ctx.parentCtx;
      if (ctx === undefined || ctx === null) {
        return 0;
      }
    }
    return ctx.indentDepth;
  }

  /**
   * Helper to check if process, emit, or template is required.
   *
   * @param setType {Object}
   * @param ctx {ParserContext}
   * @return {String}
   */
  leafHelper(setType, ctx) {
    ctx.type = setType;
    this.requiredImports[ctx.type.code] = true;
    // Pass the original argument type to the template, not the casted type.
    const type = ctx.originalType === undefined ? ctx.type : ctx.originalType;
    if (`process${ctx.type.id}` in this) {
      return this[`process${ctx.type.id}`](ctx);
    }
    if (`emit${ctx.type.id}` in this) {
      return this[`emit${ctx.type.id}`](ctx);
    }

    if (ctx.type.template) {
      return ctx.type.template(this.visitChildren(ctx), type.id);
    }

    return this.visitChildren(ctx);
  }

  visitString_literal(ctx) {
    ctx.type = this.Types._string;
    this.requiredImports[ctx.type.code] = true;
    // Pass the original argument type to the template, not the casted type.
    const type = ctx.originalType === undefined ? ctx.type : ctx.originalType;

    let result = this.visitChildren(ctx);
    result = result.replace(/^([rubf]?[rubf]["']|'''|"""|'|")/gi, '');
    result = result.replace(/(["]{3}|["]|[']{3}|['])$/, '');
    if (`emit${ctx.type.id}` in this) {
      return this[`emit${ctx.type.id}`](ctx, result);
    }

    if (ctx.type.template) {
      return ctx.type.template(result, type.id);
    }
    return `'${result}'`;
  }
  visitInteger_literal(ctx) {
    return this.leafHelper(this.Types._long, ctx);
  }
  visitOct_literal(ctx) {
    return this.leafHelper(this.Types._octal, ctx);
  }
  visitOct_literal(ctx) {
    return this.leafHelper(this.Types._octal, ctx);
  }
  visitHex_literal(ctx) {
    return this.leafHelper(this.Types._hex, ctx);
  }
  visitBin_literal(ctx) {
    return this.leafHelper(this.Types._bin, ctx);
  }
  visitFloat_literal(ctx) {
    return this.leafHelper(this.Types._decimal, ctx);
  }
  visitImag_literal(ctx) {
    return this.leafHelper(this.Types._long, ctx); // TODO: imaginary numbers?
  }
  visitBoolean_literal(ctx) {
    return this.leafHelper(this.Types._bool, ctx);
  }
  visitNone_literal(ctx) {
    return this.leafHelper(this.Types._null, ctx);
  }
  visitObject_literal(ctx) {
    if (this.idiomatic && 'emitIdiomaticObjectLiteral' in this) {
      return this.emitIdiomaticObjectLiteral(ctx);
    }
    this.requiredImports[10] = true;
    ctx.type = this.Types._object;
    ctx.indentDepth = this.getIndentDepth(ctx) + 1;
    let args = '';
    if (ctx.dictorsetmaker()) {
      const properties = ctx.dictorsetmaker().test();
      if (ctx.type.argsTemplate) {
        args = ctx.type.argsTemplate(
          properties
            .map((key, i) => {
              if (i % 2 === 0) {
                return [
                  this.visit(key),
                  this.visit(properties[i + 1])
                ];
              }
              return null;
            })
            .filter((k) => (k !== null)),
          ctx.indentDepth);
      } else {
        args = this.visit(properties);
      }
    }
    if (ctx.type.template) {
      return ctx.type.template(args, ctx.indentDepth);
    }
    return this.visitChildren(ctx);
  }

  visitSet_literal(ctx) {
    ctx.type = this.Types._array;
    ctx.indentDepth = this.getIndentDepth(ctx) + 1;
    this.requiredImports[9] = true;
    let args = '';
    const list = ctx.testlist_comp();
    if (list) {
      // Sets of 1 item is the same as the item itself, but keep parens for math
      if (list.children.length === 1) {
        return `(${this.visit(list.children[0])})`;
      }
      const visitedChildren = list.children.map((child) => {
        return this.visit(child);
      });
      const visitedElements = visitedChildren.filter((arg) => {
        return arg !== ',';
      });
      if (ctx.type.argsTemplate) { // NOTE: not currently being used anywhere.
        args = visitedElements.map((arg, index) => {
          const last = !visitedElements[index + 1];
          return ctx.type.argsTemplate(arg, ctx.indentDepth, last);
        }).join('');
      } else {
        args = visitedElements.join(', ');
      }
    }
    if (ctx.type.template) {
      return ctx.type.template(args, ctx.indentDepth);
    }
    return this.visitChildren(ctx);
  }
  visitArray_literal(ctx) {
    ctx.type = this.Types._array;
    ctx.indentDepth = this.getIndentDepth(ctx) + 1;
    this.requiredImports[9] = true;
    let args = '';
    if (ctx.testlist_comp()) {
      const visitedChildren = ctx.testlist_comp().children.map((child) => {
        return this.visit(child);
      });
      const visitedElements = visitedChildren.filter((arg) => {
        return arg !== ',';
      });
      if (ctx.type.argsTemplate) { // NOTE: not currently being used anywhere.
        args = visitedElements.map((arg, index) => {
          const last = !visitedElements[index + 1];
          return ctx.type.argsTemplate(arg, ctx.indentDepth, last);
        }).join('');
      } else {
        args = visitedElements.join(', ');
      }
    }
    if (ctx.type.template) {
      return ctx.type.template(args, ctx.indentDepth);
    }
    return this.visitChildren(ctx);
  }

  /**
   * Visit a leaf node and return a string.
   * *
   * @param {ParserRuleContext} ctx
   * @returns {String}
   */
  visitTerminal(ctx) {
    return ctx.getText();
  }

  visitTerm(ctx) {
    // Skip if fake node
    if (ctx.getChildCount() === 1) {
      return this.visitChildren(ctx);
    }
    if (ctx.getChildCount() > 2) {
      const res = [this.visit(ctx.children[0])];
      for (let i = 1; i < ctx.getChildCount(); i++) {
        const op = this.visit(ctx.children[i]);
        if (op === '//') {
          const rhs = this.visit(ctx.children[i + 1]);
          const lhs = res.pop();
          res.push(this.Syntax.floorDiv.template(lhs, rhs));
          i++;
        } else {
          res.push(op);
        }
      }
      return res.join('');
    }
    return this.visitChildren(ctx);
  }

  visitPower(ctx) {
    // Skip if fake node
    if (ctx.getChildCount() === 1) {
      return this.visitChildren(ctx);
    }
    return this.Syntax.power.template(this.visit(ctx.atom_expr()), this.visit(ctx.factor()));
  }

  visitComparison(ctx) {
    // Skip if fake node
    if (ctx.getChildCount() === 1) {
      return this.visitChildren(ctx);
    }
    let skip = false;
    return ctx.children.reduce((str, e, i, arr) => {
      if (skip) { // Skip for 'in' statements because swallows rhs
        skip = false;
        return str;
      }
      if (i === arr.length - 1) { // Always visit the last element
        return ` ${str}${this.visit(e)}`;
      }
      if (i % 2 === 0) { // Only ops
        return str;
      }
      const op = this.visit(e);
      if (op === '==' || op === '!=' || op === 'is' || op === 'isnot') {
        return `${str}${this.Syntax.equality.template(this.visit(arr[i - 1]), op, '')}`;
      }
      if (op === 'in' || op === 'notin') {
        skip = true;
        return `${str}${this.Syntax.in.template(this.visit(arr[i - 1]), op, this.visit(arr[i + 1]))}`;
      }
      return `${str}${this.visit(arr[i - 1])} ${op} `;
    }, '');
  }

  // accessors
  getList(ctx) {
    if (!('testlist_comp' in ctx) || !ctx.testlist_comp()) {
      return [];
    }
    return ctx.testlist_comp().test();
  }
  getArray(ctx) {
    return this.skipFakeNodesDown(ctx, 'array_literal');
  }
  getObject(ctx) {
    return this.skipFakeNodesDown(ctx, 'object_literal');
  }
  getKeyValueList(ctx) {
    if ('dictorsetmaker' in ctx && ctx.dictorsetmaker()) {
      const properties = ctx.dictorsetmaker().test();
      return properties
        .map((key, i) => {
          if (i % 2 === 0) {
            return [
              key,
              properties[i + 1]
            ];
          }
          return null;
        })
        .filter((k) => (k !== null));
    }
    return [];
  }
  getKeyStr(k) {
    return removeQuotes(this.visit(k[0]));
  }
  getParentKeyStr(ctx) { // TODO: fix for long list
    const topNode = this.getParentUntil(ctx.parentCtx, 'dictorsetmaker', 1);
    const objNode = topNode.parentCtx;
    const index = objNode.test().indexOf(topNode);
    const keyNode = objNode.test()[index - 1];
    const key = this.visit(keyNode);
    return removeQuotes(key);
  }
  getValue(k) {
    return k[1];
  }
  getParentUntil(ctx, name, steps) {
    steps = steps === undefined ? 0 : steps;
    let res = ctx;
    let found = false;
    const stack = [];
    while (res !== undefined && res !== null && !found) {
      if (name in res) {
        const goal = res[name]();
        if (goal === stack[stack.length - 1]) {
          found = true;
          break;
        }
      }
      stack.push(res);
      res = res.parentCtx;
    }
    return found ? stack[stack.length - 1 - steps] : false;
  }
  skipFakeNodesDown(ctx, goal) {
    let res = ctx;
    while (res.children !== undefined && res.children.length === 1) {
      res = res.children[0];
      if (goal && goal in res) {
        res = res[goal]();
        break;
      }
    }
    return res;
  }
  skipFakeNodesUp(ctx, goal) {
    let res = ctx.parentCtx;
    while (res !== undefined && res !== null && res.children !== undefined && res.children.length === 1) {
      if (goal && goal in res) {
        res = res[goal]();
        break;
      }
      res = res.parentCtx;
    }
    return res;
  }
  isSubObject(ctx) {
    return this.getParentUntil(ctx.parentCtx, 'dictorsetmaker', 1);
  }
  getObjectChild(ctx) {
    return this.skipFakeNodesDown(ctx);
  }
}

module.exports = Visitor;
