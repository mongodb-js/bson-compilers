/* eslint complexity: 0 */
const Python3Visitor = require('../../lib/antlr/Python3Visitor').Python3Visitor;

/**
 * This is a Visitor that visits the tree generated by the Python3.g4 grammar.
 *
 * @returns {Visitor}
 */
class Visitor extends Python3Visitor {
  constructor() {
    super();
  }
  /**
   * Selectively visits children of a node.
   *
   * @param {ParserRuleContext} ctx
   * @param {Object} options:
   *    start - child index to start iterating at.
   *    end - child index to end iterating after.
   *    step - how many children to increment each step, 1 visits all children.
   *    separator - a string separator to go between children.
   *    ignore - an array of child indexes to skip.
   *    children - the set of children to visit.
   * @returns {String}
   */
  visitChildren(ctx, options) {
    // console.log(`visitChildren: ${ctx.constructor.name} children.length=${ctx.children.length}`);
    const opts = {
      start: 0, step: 1, separator: ' ', ignore: [], children: ctx.children
    };
    Object.assign(opts, options ? options : {});
    opts.end = ('end' in opts) ? opts.end : opts.children.length;

    let code = '';
    for (let i = opts.start; i < opts.end; i += opts.step) {
      if (opts.ignore.indexOf(i) === -1) {
        code = `${ code }${ this.visit(opts.children[i]) }${
          (i === opts.end - 1) ?
            '' :
            opts.separator
        }`;
      }
    }
    /* Set the node's type to the first child, if it's not already set.
      More often than not, type will be set directly by the visitNode method. */
    if (ctx.type === undefined) {
      ctx.type = opts.children.length ?
        opts.children[0].type :
        this.Types._undefined;
    }
    return code.trim();
  }
  start(ctx) {
    return this.visitSingle_input(ctx);
  }

  /**
   * Visit a leaf node and return a string.
   * *
   * @param {ParserRuleContext} ctx
   * @returns {String}
   */
  visitTerminal(ctx) {
    return ctx.getText();
  }
}

module.exports = Visitor;
